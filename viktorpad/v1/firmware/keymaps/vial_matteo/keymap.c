/*
 * Copyright 2025 saifymatteo <dev@saifulmashuri.com>
 */

#include QMK_KEYBOARD_H
#include "os_detection.h"

#if __has_include("keymap.h")
#    include "keymap.h"
#endif

// LAYER --------------------------------------------------------------

// Clear keycode timer;
uint16_t keycode_timer = 0;

enum custom_keycodes {
    ALT_GUI_KC = SAFE_RANGE,
};

KEYCODE_STRING_NAMES_USER(           //
    KEYCODE_STRING_NAME(ALT_GUI_KC), //
    KEYCODE_STRING_NAME(KC_APP),     //
    KEYCODE_STRING_NAME(KC_MUTE),    //
    KEYCODE_STRING_NAME(DB_TOGG)     //
);

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = //
    {[0] = LAYOUT(                                           //
         KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,        //
         KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,        //
         KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,                 //
         KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS         //
         ),
     [1] = LAYOUT(                                    //
         KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, //
         KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, //
         KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,          //
         KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS  //
         ),
     [2] = LAYOUT(                                    //
         KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, //
         KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, //
         KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,          //
         KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS  //
         )};

layer_state_t layer_state_set_user(layer_state_t state) {
    oled_clear();
    return state;
}

// ENCODER --------------------------------------------------------------

const uint16_t PROGMEM encoder_map[][NUM_ENCODERS][2] = {
    [0] = {ENCODER_CCW_CW(MS_WHLU, MS_WHLD), ENCODER_CCW_CW(KC_VOLD, KC_VOLU), ENCODER_CCW_CW(KC_VOLD, KC_VOLU)},
    [1] = {ENCODER_CCW_CW(UG_HUED, UG_HUEU), ENCODER_CCW_CW(UG_SATD, UG_SATU), ENCODER_CCW_CW(UG_SATD, UG_SATU)},
    [2] = {ENCODER_CCW_CW(UG_VALD, UG_VALU), ENCODER_CCW_CW(UG_SPDD, UG_SPDU), ENCODER_CCW_CW(UG_SPDD, UG_SPDU)},
};

// Alt (Windows) / Command (MacOS)
// Taken from
// [reddit](https://www.reddit.com/r/MechanicalKeyboards/comments/s52e51/added_alttab_to_my_rotary_encoder_on_my_qmk_board/)
bool     is_alt_tab_active       = false;
bool     is_alt_shift_tab_active = false;
uint16_t alt_tab_timer           = 0;

// // Note: disable ENCODER_MAP_ENABLE for custom encoder handling
// bool encoder_update_user(uint8_t index, bool clockwise) {
//     os_variant_t current_os = detected_host_os();

//     // Update keycode timer
//     keycode_timer = timer_read();

//     // Set matrix for Rotary rotation
//     oled_set_cursor(0, 3);

//     if (clockwise) {
//         oled_write_ln("--RE->", false);
//         // print("Encoder: clockwise\n");
//     } else {
//         oled_write_ln("<-RE--", false);
//         // print("Encoder: counter clockwise\n");
//     }

//     // Set keycode for Rotary rotation
//     oled_set_cursor(8, 3);

//     switch (get_highest_layer(layer_state | default_layer_state)) {
//         case 0:
//         case 1:
//             // Alt tab / shift alt tab
//             // Windows: Alt tab (need to hold alt)
//             // MacOS: Command tab (need to hold command)
//             register_code(current_os == OS_MACOS ? KC_LEFT_CTRL : KC_LALT);
//             if (clockwise) {
//                 if (!is_alt_tab_active) {
//                     is_alt_tab_active = true;
//                 }
//                 alt_tab_timer = timer_read();
//                 tap_code(KC_TAB);
//                 oled_write_ln("RE_ALT_GUI_KC", false);
//             } else {
//                 if (!is_alt_shift_tab_active) {
//                     is_alt_shift_tab_active = true;
//                 }
//                 alt_tab_timer = timer_read();
//                 tap_code16(LSFT(KC_TAB));
//                 oled_write_ln("RE_ALT_GUI_KC", false);
//             }
//             break;
//         case 2:
//             // Volume up / down
//             if (clockwise) {
//                 tap_code(KC_VOLU);
//                 oled_write_ln("RE_VOLU", false);
//             } else {
//                 tap_code(KC_VOLD);
//                 oled_write_ln("RE_VOLD", false);
//             }
//             break;
//     }

//     return false;
// }

// OLED --------------------------------------------------------------

// Keyboard Matrix. Taken from
// [github](https://github.com/vuon0029/qmk/tree/master/keyboards/mechwild/mercutio/keymaps/dracutio)
// Bongo cat OLED. Taken from [github](https://github.com/nwii/oledbongocat)

// Custom animation guide:
// 1. Get a any video or gif
// 2. To convert video to gif, use this: `ffmpeg -i <video-file> -vf "fps=10"
// -loop 0 <gif-output>`
// 3. Convert from Gif.
// [github](https://github.com/AskMeAboutBirds/qmk-oled-animation-compressor)

// Keyboard Matrix display
#define MATRIX_DISPLAY_X 20
#define MATRIX_DISPLAY_Y 18

// Keyboard Unit size
#define GAP 1
#define CUBE_NUMBER 3

// Bongo cat
#define TAP_FRAMES 2
#define ANIMATION_FRAME_DURATION 200 // how long each frame lasts in ms
#define ANIMATION_SIZE \
    1024 // number of bytes in array, minimize for adequate firmware size, max is
         // 1024

// Bongo cat variables
uint32_t animation_timer   = 0;
uint8_t  current_tap_frame = 0;

// Bongo cat animations
static const char PROGMEM bongo_tap[TAP_FRAMES][ANIMATION_SIZE] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x40, 0x40, 0x20, 0x20, 0x10, 0x08, 0x04, 0x02, 0x04, 0x08, 0x10, 0x10, 0x20, 0x20, 0x40, 0x40, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc1, 0x01, 0x01, 0x02, 0x02, 0x04, 0x04, 0x04, 0x04, 0x02, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x40, 0x80, 0x80, 0x40, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x64, 0x18, 0x04, 0x12, 0xc2, 0xca, 0x24, 0x88, 0xf0, 0x80, 0x80, 0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20, 0x20, 0x10, 0x10, 0x10, 0x10, 0x08, 0x08, 0x08, 0x08, 0x04, 0x04, 0x04, 0x04, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x18, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x83, 0x83, 0x40, 0x40, 0x40, 0x40, 0x20, 0x21, 0x21, 0x20, 0x10, 0x10, 0x10, 0x10, 0x08, 0x08, 0x08, 0x08, 0x04, 0x04, 0x04, 0x04, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20, 0x20, 0x10, 0x10, 0x10, 0x10, 0x08, 0x0f, 0x08, 0x08, 0x04, 0x04, 0x04, 0x04, 0x02, 0x04, 0x08, 0x10, 0x10, 0x20, 0x20, 0x40, 0x40, 0x41, 0x42, 0x24, 0x98, 0xc0, 0x88, 0x88, 0x8c, 0x9c, 0x1c, 0x1e, 0x0e, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x40, 0x40, 0x20, 0x20, 0x10, 0x08, 0x04, 0x02, 0x04, 0x08, 0x10, 0x10, 0x20, 0x20, 0x40, 0x40, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc1, 0x01, 0x01, 0x02, 0x02, 0x04, 0x84, 0x44, 0x44, 0x42, 0x82, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x40, 0x80, 0x80, 0x40, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x04, 0x08, 0x08, 0x10, 0x20, 0x40, 0x80, 0x80, 0x80, 0x80, 0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20, 0x20, 0x10, 0x10, 0x10, 0x10, 0x08, 0x08, 0x08, 0x08, 0x04, 0x04, 0x04, 0x04, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x18, 0x06, 0x01, 0x00, 0x00, 0x0c, 0x03, 0x00, 0x02, 0x18, 0x19, 0x00, 0x05, 0xfe, 0x80, 0x83, 0x83, 0x40, 0x40, 0x40, 0x40, 0x20, 0x21, 0x21, 0x20, 0x10, 0x10, 0x10, 0x10, 0x08, 0x08, 0x08, 0x08, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x30, 0x40, 0x80, 0x80, 0x00, 0x00, 0x01, 0x86, 0x98, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20, 0x20, 0x10, 0x10, 0x10, 0x10, 0x08, 0x0f, 0x08, 0x08, 0x04, 0x04, 0x04, 0x04, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x0f, 0x0f, 0x07, 0x03, 0x03, 0x61, 0xf0, 0xf8, 0xfc, 0x60, 0x01, 0x01, 0x01, 0x3c, 0x78, 0xf8, 0xf0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
};

oled_rotation_t oled_init_user(oled_rotation_t rotation) {
    return OLED_ROTATION_180;
}

bool oled_task_user(void) {
    uint8_t current_layer = get_highest_layer(layer_state | default_layer_state);

    if (current_layer == 1) { // QWERTY layer
        // Render bongo cat
        if (timer_elapsed32(animation_timer) > ANIMATION_FRAME_DURATION) {
            animation_timer = timer_read32();

            current_tap_frame = (current_tap_frame + 1) % TAP_FRAMES;
            oled_write_raw_P(bongo_tap[abs((TAP_FRAMES - 1) - current_tap_frame)], ANIMATION_SIZE);
        }
    } else {
        // Render Keyboard Box
        oled_set_cursor(0, 0);
        for (uint8_t x = 0; x < MATRIX_DISPLAY_X; x++) {
            oled_write_pixel(x, 0, true);
        }
        for (uint8_t y = 0; y < MATRIX_DISPLAY_Y; y++) {
            oled_write_pixel(0, y, true);
        }
        for (uint8_t x = 0; x < MATRIX_DISPLAY_X; x++) {
            oled_write_pixel(x, MATRIX_DISPLAY_Y, true);
        }
        for (uint8_t y = 0; y < MATRIX_DISPLAY_Y; y++) {
            oled_write_pixel(MATRIX_DISPLAY_X, y, true);
        }

        // Render OS
        oled_set_cursor(8, 1);
        switch (detected_host_os()) {
            case OS_LINUX:
                oled_write_ln("OS : Linux", false);
                break;
            case OS_WINDOWS:
                oled_write_ln("OS : Windows", false);
                break;
            case OS_MACOS:
                oled_write_ln("OS : MacOS", false);
                break;
            case OS_IOS:
                oled_write_ln("OS : iOS", false);
                break;
            case OS_UNSURE:
                oled_write_ln("OS : Unsure", false);
                break;
        }

        // Render Layers
        oled_set_cursor(8, 2);
        switch (current_layer) {
            case 0:
                oled_write_ln("Colemak-DH", false);
                break;
            case 1:
                oled_write_ln("QWERTY", false);
                break;
            case 2:
                oled_write_ln("Functions", false);
                break;
            default:
                oled_write_ln("Undefined", false);
        }

        if (timer_elapsed(keycode_timer) > 1000) {
            oled_set_cursor(0, 3);
            oled_advance_page(true);
        }
    }

    return false;
}

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    os_variant_t current_os = detected_host_os();

    uint8_t current_layer = get_highest_layer(layer_state | default_layer_state);
    if (current_layer != 1) {
        // Row and column swapped based on config
        // - Max row = 5 + 1 encoder row
        // - Max column = 12
        uint8_t row    = record->event.key.row;
        uint8_t column = record->event.key.col;

        // Render Row and Column text
        oled_set_cursor(0, 3);
        oled_write_P(PSTR("R"), false);
        oled_write(get_u8_str(row, '0'), false);
        oled_write_P(PSTR("-C"), false);
        oled_write_ln(get_u8_str(column, ' '), false);

        // Render current key name
        oled_set_cursor(8, 3);
        oled_write_ln(get_keycode_string(keycode), false);

        // Render keyboard tap, switch back the row/column on master side
        for (uint8_t x = (CUBE_NUMBER * row) + GAP; x < CUBE_NUMBER * (row + 1); x++) {
            for (uint8_t y = (CUBE_NUMBER * column) + GAP; y < CUBE_NUMBER * (column + 1); y++) {
                oled_write_pixel(y, x, record->event.pressed);
            }
        }
    }

    // Update timer
    keycode_timer = timer_read();

    switch (keycode) {
        case ALT_GUI_KC:
            if (record->event.pressed) {
                if (current_os == OS_WINDOWS || current_os == OS_LINUX) {
                    // Windows | Open Task View
                    tap_code16(LGUI(KC_TAB));
                } else if (current_os == OS_MACOS) {
                    // MacOS | Open Mission Control
                    tap_code(KC_MISSION_CONTROL);
                }
            }
            break;
    }
    return true;
};

void matrix_scan_user(void) {
    // ALT key hold timer
    if (is_alt_tab_active | is_alt_shift_tab_active) {
        if (timer_elapsed(alt_tab_timer) > 500) {
            unregister_code(detected_host_os() == OS_MACOS ? KC_LEFT_CTRL : KC_LALT);
            is_alt_tab_active       = false;
            is_alt_shift_tab_active = false;
        }
    }
};

// END OF FILE
